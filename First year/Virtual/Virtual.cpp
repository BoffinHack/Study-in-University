/*
 * Программа составляет список геометрических фигур в динамической памяти.
 * Существует абстрактный класс, от которого наследуются классы треугольника и квадрата.
 * Вывод площади фигур и их параметров (координаты x0, y0 и длину прямой a).
 * Фигуру можно вставлять в начало списка, конец или по определенному номеру.
 * Фигуру можно извлекать из начала списка, конца или по определенному номеру.
 * Можно получать адрес фигуры начала, конца или по определенному номеру.
 * Можно удалять фигуру из начала, конца или по определенному номеру.
 * Можно объединять списки фигур.
*/
#include <iostream>

using namespace std;

class fig{ //абстрактный класс fig, фигура
    //Абстрактный класс — это класс, в котором хотя бы один метод является виртуальным.
    //А виртуальный метод — это метод, который должен быть переопределен в производных классах.

protected: //такой метод, доступ к которому можно получить только из того же класса (или объекта того же класса) и из его наследников

    float x0, y0; //переменные типа float, координаты
    float a; //переменная типа float, прямая

public: //такой метод, доступ к которому можно получить откуда угодно - извне определенного класса, из объекта определенного класса, из наследников

    //конструктор абстрактного класса fig
    fig(float x1=0, float y1=0, float a1=0): x0(x1), y0(y1), a(a1){} // ":" означает, что мы напрямую инициализируем переменные - члены класса

    virtual float sqr() const = 0; //виртуальный метод. Любой порожденный класс может его переопределить.
    //Чтобы определить виртуальный метод как чистый, его объявление завершается значением "const = 0"
    //метод возвращает значение типа float

    //виртуальный метод. любой порожденный класс может его переопределить.
    virtual fig* copyf() const = 0;//виртуальный метод, который будет возвращать указатель на порожденный класс, полученного из абстрактного базового класса

    //виртуальный метод. любой порожденный класс может его переопределить.
    virtual ostream& show(ostream& os){
        return os<<"x0 = "<<x0<<", y0 = "<<y0;
    }
    //перегрузка оператора вывода
    //дружественная функция перегрузки оператора <<
    //дружественная функция нужна для доступа к методу private
    friend ostream &operator<<(ostream &os, fig &tmp){ //левым операндом является объект cout, а правым - порожденный класс
        return tmp.show(os); //возвращаем значение функции show порожденного класса
    }
};

class tre: public fig{ //класс tre, треугольник, наследник абстрактного класса fig, имеет доступ к методу public класса fig
    //члены класса, определенного с помощью ключевого слова class, по умолчанию являются private

    float h; //переменные типа float, высота треугольника

public:

    //конструктор класса tre
    //перепенные x1, y1, a1 определены в базовом классе, поэтому для их инициализации нам нужно вызвать конструктор базового класса
    //после мы напрямую инициализируем h
    tre(float x1, float y1, float a1, float h1):fig(x1, y1, a1), h(h1){}

    //создаем объект в динамической памяти и возвращаем указатель на него
    fig* copyf() const{
        return new tre(x0, y0, a, h); //так как у нас тип класс и конструктор класса имеет параметры, то записываем (x0, y0, a, h)
    }

    //функция для подсчета площади треугольника
    float sqr() const{
        return a*h/2; //возвращаем площадь
    }

    //переопределенная функция вывода информации о фигуре
    ostream& show(ostream& os){
        fig::show(os); //обращаемся к функции show абстрактного базового класса
        return os<<", osnovanie = "<<a<<", vysota = "<<h<<endl; //вывод доп сведений о фигуре
    }
};

class kv: public fig{ //класс kv, квадрат, наследник абстрактного класса fig, имеет доступ к методу public класса fig

public:

    //конструктор класса kv
    //перепенные x1, y1, a1 определены в базовом классе, поэтому для их инициализации нам нужно вызвать конструктор базового класса
    kv (float x1, float y1, float a1):fig(x1, y1, a1){}

    //создаем объект в динамической памяти и возвращаем указатель на него
    fig* copyf() const{
        return new kv(x0, y0, a); //когда используется ключевое слово new,
        //компилятор выделяет необходимую память, а затем вызывает конструктор для создания нового объекта в выделенной памяти.
        //затем new возвращает указатель на этот блок памяти.
    }

    //функция для подсчета площади квадрата
    float sqr() const{
        return a*a; //возвращаем площадь
    }

    //переопределенная функция вывода информации о фигуре
    ostream& show(ostream& os){
        fig::show(os);//обращаемся к функции show базового класса
        return os<<", storona = "<<a<<endl;//вывод доп сведений о фигуре
    }
};

//Узел списка фигур
//члены класса, определенного в struct el, по умолчанию являются public
struct el{

    //указатель на астрактный базовый класс
    //означает, что в этот указатель мы можем присвоить ссылку на любого наследника абстрактного класса fig
    fig* pf;

    //указатель на следующий элемент
    el* next;

    //перегруженный конструктор класса
    el():pf(0),next(0){} //если ничего не передаем при инициализациии объекта, то значения равны 0

    //перегруженный конструктор класса
    el(fig* f):pf(f),next(0){} // где напрямую инициализируем указатель pf, записывая в него указатель на порожденный класс
    //и инициализируем указатель на следующий элемент 0

    //деконструктор класса el
    ~el(){
        //в pf у нас указатель на созданный объект в динамической памяти порожденного класса
        delete pf->copyf();
    }
};

//список фигур
//члены класса, определенного с помощью ключевого слова class, по умолчанию являются private
class flist{

    el* elf; //указатель типa struct el, начало списка

public://такой метод, доступ к которому можно получить откуда угодно - извне определенного класса, из объекта определенного класса, из наследников


    //перегруженный конструктор класса
    flist():elf(0){} //где, если ничего не передаем при инициализациии объекта elf = 0

    //перегруженный конструктор класса, используем, чтобы при создании нового списка, могли записать в него старый список фигур
    //const flist& - константная ссылка типа класс flist, const означает, что конструктор не изменит значение, на которое ссылается ссылка
    //":" означает, что мы напрямую инициализируем переменную elf = 0
    flist(const flist& fl):elf(0){
        //1)записываем в указатель типа struct el, указатель struct elf, начало списка
        //2)проверяем что указателю e назначен адрес участка памяти, перемещаемся по списку
        //3)перемещаемся по списку, с помощью e=e->next (такая запись, чтобы указатель на первый элемент elf оставался указателем на первый элемент), пока не достигнем 0
        for(el* e=fl.elf;e;e=e->next)
            ins_end(*(e->pf->copyf()));//передаем в функцию порожденный класс, разыменованный указатель на созданный объект порожденного класса
    }

    //деструктор класса flist
    ~flist(){
        //записываем в указатель e, указаетль elf, указывающий на первый элемент в списке
        //проверяем что указателю e назначен адрес участка памяти, перемещаемся по списку
        //перемещаемся по списку, с помощью e=elf->next
        for(el* e=elf;e;e=elf->next){
            //создаем указатель t на следующий элемент в списке
            el* t = elf->next;
            //удаляем первый элемент в списке
            delete elf;
            //записываем указатель в elf, начало списка, указатель на следующий элемент, который указывал удаляемый объект, t
            elf = t;
        }
    }

    //функция получения размера списка
    int get_size(){

        //начало списка
        int i = 0;

        //1)записываем в указатель типа struct el, указатель struct elf, начало списка
        //2)проверяем что указателю e назначен адрес участка памяти, перемещаемся по списку
        //3)перемещаемся по списку, с помощью e=e->next
        //4)считаем количество элементов, i++
        for(el* e=elf;e;e=e->next,i++);

        //ввозвращаем количество элементов
        return i;
    }

    //функция получения адреса элемента под номером n
    el* get_pos(int n){

        //проверяем что указателю elf назначен адрес участка памяти
        if(!elf){
            //если указателю не назначен адрес участка памяти,  товыводим сообщение об ошибке
            cerr<<"List is empty!"<<endl;
            //cerr стандартный поток ошибок, который используется для вывода ошибок.
            //cerr является небуферизованный поэтому он используется, когда нам нужно немедленно отобразить сообщение об ошибке.
            //У него нет буфера для хранения сообщения об ошибке и отображения позже.
            return 0;
        }

        //если номер элемента начало списка или меньше, то выводим адрес начала списка
        if(n<=0)
            return elf;

        //если номер элемента больше, чем количесво элементов в списке или равно номеру последнему элементу
        if(n>=get_size()){
            //1)записываем в указатель типа struct el, указатель struct elf, начало списка
            //2)пока указатель на следующий элемент не будет указывать на пустоту, перемещаемся по списку
            //3)перемещаемся по списку, с помощью e=e->next
            for(el* e=elf;e->next;e=e->next)
                //возвращаем указатель на последний элемент
                return e;
        }

        //переменная для поиска элемента в списке, если элемент не в начале или в конце
        int i=0;

        //1)записываем в указатель типа struct el, указатель struct elf, начало списка
        //2)проверяем что указателю e назначен адрес участка памяти, перемещаемся по списку
        //3)перемещаемся по списку, с помощью e=e->next
        //4)ищем номер элемента, i++
        for(el* e=elf;e;e=e->next,i++)
            //если номер элемента совпал с искомым
            if(i==n)
                //то возвращаем указатель на искомый элемент
                return e;
    }

    //функция получения адреса первого элемента
    el* get_beg(){
        //возвращаем указатель на первый элемент
        return get_pos(0); //с помощью функции получаем адрес первого элемента, 0 т.к. счет начинается с 0
    }

    //функция получения адреса последнего элемента
    el* get_end(){
        //возвращаем указатель на последний элемент
        return get_pos(get_size()-1);//с помощью функции получаем адрес последнего элемента, отнимаем от общего количество элементов 1, т.к. счет начинается с 0
    }

    //функция извлечения элемента под номером n
    el* pop_pos(int n){

        //проверяем что указателю elf назначен адрес участка памяти
        if(!elf){
            //если указателю не назначен адрес участка памяти,  товыводим сообщение об ошибке
            cerr<<"List is empty!";
            //cerr стандартный поток ошибок, который используется для вывода ошибок.
            //cerr является небуферизованный поэтому он используется, когда нам нужно немедленно отобразить сообщение об ошибке.
            //У него нет буфера для хранения сообщения об ошибке и отображения позже.
            return 0;
        }

        //создаем указатель типа struct el, e
        el *e;
        //создаем указатель типа struct el, t
        el *t;

        //если номер вставляемого элемента меньше чем 0
        if(n<=0){
            //то извлекаем элемент из начала
            //записываем в указатель e, указатель elf, начало списка
            e=elf;
            //записываем, что начало списка теперь следующий элемент
            elf=elf->next;
        //иначе
        }else{
            //в i записываем количество элементов в списке
            int i=get_size();
            //если номер извлекаемого элемента больше, чем количество элементов
            if(n>i)
                //то записываем в n количество элементов
                n=i;
            //записываем в указатель t, указатель на позицию предпоследнего элемента
            t=get_pos(n-1);// n-1, номер предпоследнего элемента
            //записываем в указатель e, указатель на следующий элемент, на который указывает предпоследний элемент, а предпоследний указывает на пследний
            e=t->next;
            //теперь указатель предпоследнего элемента на следующий элемент, равен указателю на следующий элемент извлекаемого элемента, то есть на пустоту
            t->next=e->next;
        }

        //возвращаем адрес извлекаемого элемента
        return e;
    }

    //функция извлечения из начала списка
    el* pop_beg(){
        //возвращаем адрес извлекаемого элемента
        return pop_pos(0); //0 т.к. номер первого элемента равен 0
    }

    //функция извлечения из конца списка
    el* pop_end(){
        //возвращаем адрес извлекаемого элемента
        return pop_pos(get_size()-1);//чтобы получить номер конца списка, отнимаем от общего количество элементов 1, т.к. так как счет начинается с 0
    }

    //функция которая принимает ссылку на порожденный класс и переменную типа int, потом возвращает указатель на текущий объект
    //функция вставляет элемент в список под номером n
    flist& ins_pos(fig& f, int n){

        //создаем елемент типа struct el в динамической памяти
        el *t=new el(f.copyf()); //передаем в конструктор указатель на порожденный класс, созданный в динамической памяти

        //если n меньше или равно 0
        if(n<=0){
            //то записываем, что в новосозданном элементе t, указатель на следующий элемент равен указателю elf, началу списка
            t->next=elf;
            //а начало списка теперь новосозданный элемент
            elf = t; //в указатель elf записываем указатель t
        }else{//иначе, если n больше 0
            //то создаем переменную типа int и записываем в нее размер списка
            int i=get_size();
            //после проверяем
            if(n>i) //если n больше, чем количество элементов в списке
                n=i; //то записываем в n количество элементов
            //после создаем указатель в который записываем ???????указатель на элемент, позицию которого получили в get_pos????????
            el* e=get_pos(n-1);
            //в новосозданном элементе t, указатель на следующий элемент равен указателю на следующий элемент, элемента ??????????позицию которго получили????????
            t->next=e->next;
            //а в элементе позицию которого получили, указатель на следующий элемент равен новому созданному элементу
            e->next=t;
        }
        //возвращаем указатель на текущий объект
        return *this;
    }

    //функция которая принимает ссылку на порожденный класс, потом возвращает указатель на текущий объект
    //функция вставляет элемент в начало списка, начало списка начинаеся с 0
    flist& ins_beg(fig& f){
        return ins_pos(f,0);
    }

    //функция которая принимает ссылку на порожденный класс, потом возвращает указатель на текущий объект
    //функция вставляет элемент в конец списка
    flist& ins_end(fig& f){
        return ins_pos(f,get_size()-1); //get_size - размер списка, отнимаем от общего количество элементов 1, т.к. так как счет начинается с 0
    }

    //функция, которая удаляет элемент в списке под номером n
    int del_pos(int n){

        //записываем в указатель типа struct el, указатель удаляемого элемента
        el *e=pop_pos(n);

        //проверяем что указателю e назначен адрес участка памяти
        if(!e)
            //если не назнасен, то элемент не удален
            return 0;

        //иначе удаляем элеемент
        delete e;

        //говорим, что элемент удален
        return 1;
    }

    //функция, которая удаляет элемент в начале списка
    int del_beg(){
        //return посогает узнать удалили мы элемент или нет
        return del_pos(0); //удалем элемент в начале списка, 0 т.к. счет начинается с 0
    }

    //функция, которая удаляет элемент в конце списка
    int del_end(){
        //return посогает узнать удалили мы элемент или нет
        return del_pos(get_size()-1);//удалем элемент в конце списка, отнимаем от общего количество элементов 1, т.к. так как счет начинается с 0
    }

    //перегрузка оператора вывода
    //дружественная функция перегрузки оператора <<
    //дружественная функция нужна для доступа к методу private
    friend ostream& operator<<(ostream& os,flist &fs);//левым операндом является объект cout, а правым — класс flist
};

//перегрузка оператора вывода
ostream& operator<<(ostream& os,flist &f){//левым операндом является объект cout, а правым — класс flist

    //выводим список информации о геометрических фигурах
    os<<endl<<"***** List of geometric objects: *****"<<endl;

    //для нумерации фигур в списке
    int i=0;

    //1)записываем в указатель типа struct el, указатель struct elf, начало списка
    //2)проверяем что указателю e назначен адрес участка памяти, перемещаемся по списку
    //3)перемещаемся по списку, с помощью e=e->next
    //4)нумеруем фтгуры в списке, i++
    for(el* e=f.elf;e;e=e->next){
        //выводим информацию о фигуре
        os<<"i = "<<i<<", figure:"<<*e->pf<<endl;i++;
    }

    return os;
}

int main(){
    setlocale(LC_ALL,"rus");
    tre F0(10.34,11.43,9,10.4);
    kv F1(3,2.5,0.4);
    tre F2(2.4,0.3,0,21.3);

    cout<<"\nFigure tre F0"<<endl;
    cout<<F0;

    cout<<"\nFigure kv F1"<<endl;
    cout<<F1;

    cout<<"\nFigure tre F2"<<endl;
    cout<<F2;

    cout<<"\nCreating the first list of geometric objects..."<<endl;
    flist List(List);
    List.ins_beg(F0);
    List.ins_end(F1);
    List.ins_end(F2);
    cout<<List;
    cout<<"Size the first list - "<<List.get_size()<<endl;

    cout<<"\nCreatin new figure kv F4"<<endl;
    kv F4(10.01,10.1,11.1);
    cout<<"Figure kv F4"<<endl;
    cout<<F4;

    cout<<"\nInsert the figure F4 in the first list..."<<endl;
    List.ins_pos(F4,2);

    cout<<List;
    cout<<"Size the first list - "<<List.get_size()<<endl;

    cout<<"\nDeliting from the first list:"<<endl;
    cout<<"Figure 4"<<endl;
    List.del_pos(2);

    cout<<List;
    cout<<"Size the first list - "<<List.get_size()<<endl;

    cout<<"\nCreatin new figure kv F3"<<endl;
    kv F3(45.6,44.5,4.35);
    cout<<"Figure kv F3"<<endl;
    cout<<F3;

    cout<<"\nCreating the second list of geometric objects and copy the first list to the second..."<<endl;
    flist C_List(List);

    cout<<"\nInsert the figure F3 in list..."<<endl;
    C_List.ins_pos(F3,0);
    cout<<C_List;
    cout<<"Size the second list - "<<C_List.get_size()<<endl;

    cout<<"\nDeliting the first list of geometric objects..."<<endl;
    List.~flist();

    cout<<"\nGet poin from the second list:"<<endl;
    cout<<"\nFigure 0 - ";
    cout<<C_List.get_beg();
    cout<<"\nFigure 1 - ";
    cout<<C_List.get_pos(1);
    cout<<"\nFigure 2 - ";
    cout<<C_List.get_pos(2);
    cout<<"\nFigure 3 - ";
    cout<<C_List.get_end();

    cout<<"\n\nExtraction from the second list:"<<endl;
    cout<<"Figure 0"<<endl;
    C_List.pop_beg();
    cout<<"Figure 1"<<endl;
    C_List.pop_pos(0); //0 так как мы уже извлекли первую фигуру и вторая фигура стала первой
    cout<<"Figure 3"<<endl;
    C_List.pop_end();

    cout<<C_List;

    cout<<"\nDeliting from the second list:"<<endl;
    cout<<"Figure 2"<<endl;
    C_List.del_beg();

    cout<<C_List;

    C_List.~flist();
}
